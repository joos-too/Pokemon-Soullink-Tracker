#!/usr/bin/env node
import { Pokedex } from 'pokeapi-js-wrapper';
import { writeFile } from 'node:fs/promises';
import { fileURLToPath } from 'node:url';
import path from 'node:path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const outNamesPath = path.resolve(__dirname, '../src/data/pokemon-de.ts');
const outMapPath = path.resolve(__dirname, '../src/data/pokemon-de-map.ts');
const outEvoPath = path.resolve(__dirname, '../src/data/pokemon-evolutions.ts');

async function main() {
  // Disable wrapper caching in Node (localforage has no backend here)
  const P = new Pokedex({ timeout: 15000, cache: false });
  console.log('Fetching species listâ€¦');
  const list = await P.getPokemonSpeciesList({ limit: 20000, offset: 0 });
  const items = list.results || [];

  const ids = items
    .map((it) => {
      const m = it.url.match(/\/pokemon-species\/(\d+)\/?$/);
      return m ? Number(m[1]) : null;
    })
    .filter((x) => !!x);

  const results = [];
  const deToId = new Map(); // lower-case German name -> species id
  const chainIds = new Set();
  const CHUNK = 60;
  for (let i = 0; i < ids.length; i += CHUNK) {
    const slice = ids.slice(i, i + CHUNK);
    process.stdout.write(`Fetching ${i + 1}-${Math.min(i + CHUNK, ids.length)} of ${ids.length}\r`);
    const speciesArr = await Promise.all(
      slice.map((id) => P.getPokemonSpeciesByName(id).catch(() => null))
    );
    for (const sp of speciesArr) {
      if (!sp) continue;
      const namesField = sp.names || [];
      const de = namesField.find((n) => n.language?.name === 'de');
      const en = namesField.find((n) => n.language?.name === 'en');
      const nm = (de?.name || en?.name || sp.name || '').trim();
      if (nm) results.push(nm);
      if (de?.name) {
        deToId.set(String(de.name).toLowerCase(), sp.id);
      } else if (sp.name) {
        // fallback: map english to id if no de
        deToId.set(String(sp.name).toLowerCase(), sp.id);
      }
      const chainUrl = sp.evolution_chain?.url || '';
      const m2 = chainUrl && chainUrl.match(/\/evolution-chain\/(\d+)\/?$/);
      if (m2) chainIds.add(Number(m2[1]));
    }
  }

  const unique = Array.from(new Set(results)).sort((a, b) => a.localeCompare(b, 'de'));
  const namesFile = `// Generated by scripts/generate-pokemon-de.mjs\nexport const GERMAN_POKEMON_NAMES: string[] = ${JSON.stringify(unique, null, 2)};\n`;
  await writeFile(outNamesPath, namesFile, 'utf8');
  const obj = Object.fromEntries([...deToId.entries()].sort(([a],[b]) => a.localeCompare(b, 'de')));
  const mapFile = `// Generated by scripts/generate-pokemon-de.mjs\nexport const GERMAN_TO_ID: Record<string, number> = ${JSON.stringify(obj, null, 2)};\n`;
  await writeFile(outMapPath, mapFile, 'utf8');

  // Build evolutions map from evolution chains
  const evoMap = new Map();
  const chainIdArr = Array.from(chainIds);
  const CHAIN_CHUNK = 40;
  for (let i = 0; i < chainIdArr.length; i += CHAIN_CHUNK) {
    const slice = chainIdArr.slice(i, i + CHAIN_CHUNK);
    process.stdout.write(`Fetching evolution chains ${i + 1}-${Math.min(i + CHAIN_CHUNK, chainIdArr.length)} of ${chainIdArr.length}      \r`);
    const chains = await Promise.all(
      slice.map((cid) => P.getEvolutionChainById(cid).catch(() => null))
    );
    for (const ch of chains) {
      if (!ch?.chain) continue;
      const walk = (node) => {
        if (!node) return;
        const fromUrl = node.species?.url || '';
        const m = fromUrl.match(/\/pokemon-species\/(\d+)\/?$/);
        const fromId = m ? Number(m[1]) : null;
        const nextIds = [];
        const arr = Array.isArray(node.evolves_to) ? node.evolves_to : [];
        for (const child of arr) {
          const cu = child?.species?.url || '';
          const cm = cu.match(/\/pokemon-species\/(\d+)\/?$/);
          const cid2 = cm ? Number(cm[1]) : null;
          if (cid2) nextIds.push(cid2);
        }
        if (fromId && nextIds.length) {
          if (!evoMap.has(fromId)) evoMap.set(fromId, new Set());
          const s = evoMap.get(fromId);
          nextIds.forEach((id) => s.add(id));
        }
        for (const child of arr) walk(child);
      };
      walk(ch.chain);
    }
  }
  const evoObj = Object.fromEntries(
    [...evoMap.entries()].map(([k, set]) => [k, Array.from(set).sort((a, b) => a - b)])
  );
  const evoFile = `// Generated by scripts/generate-pokemon-de.mjs\nexport const EVOLUTIONS: Record<number, number[]> = ${JSON.stringify(evoObj, null, 2)};\n`;
  await writeFile(outEvoPath, evoFile, 'utf8');

  console.log(`\nWrote ${unique.length} names to ${outNamesPath}`);
  console.log(`Wrote ${Object.keys(obj).length} mappings to ${outMapPath}`);
  console.log(`Wrote ${Object.keys(evoObj).length} evolution entries to ${outEvoPath}`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
